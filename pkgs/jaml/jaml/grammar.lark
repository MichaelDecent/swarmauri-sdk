
NEWLINE: /\r?\n/  // we treat each newline as a token

// 2) Now define lines
start: line*
line: comment_line
    | blank_line
    | section
    | assignment

comment_line: COMMENT NEWLINE
blank_line: NEWLINE

assignment: IDENTIFIER (":" type_annotation)? "=" value inline_comment? NEWLINE?
inline_comment: INLINE_WS COMMENT


type_annotation: TYPE
TYPE: "str" | "int" | "float" | "bool" | "list" | "set" | "datetime"

// A section header can appear
section: "[" (section_name | STRING) "]"
section_name: IDENTIFIER ("." IDENTIFIER)*

?value: paren_expr
      | tilde_block
      | STRING
      | SCOPED_VAR
      | COMMENT
      | FLOAT
      | INTEGER
      | BOOLEAN
      | NULL
      | RESERVED_FUNC
      | KEYWORD
      | TABLE_ARRAY
      | FOLDER_BLOCK
      | inline_table
      | array
      | OPERATOR

// If you want to ignore purely horizontal spaces between tokens:
%ignore HSPACES
HSPACES: /[ \t]+/

// --------------------------
// Array Handling
// --------------------------
?array: "[" array_content? "]"

?array_content: (NEWLINE | comment_line)* array_item (ws? "," ws? ((NEWLINE | comment_line)* array_item))* (ws? "," ws?)? (NEWLINE | comment_line)*

?array_item: value inline_comment?



// --------------------------
// Inline Table Handling
// --------------------------

inline_table: "{" (HSPACES | NEWLINE)* inline_table_items? (HSPACES | NEWLINE)* "}"
inline_table_items: inline_table_item (ws? "," ws? inline_table_item)* (ws? "," ws?)?

inline_table_item: inline_assignment | comment_line

inline_assignment: IDENTIFIER (":" type_annotation)? "=" value inline_comment?



// A simple rule to capture whitespace explicitly (if you need it in the parse tree):
ws: WHITESPACE

// --------------------------
// Expressions
// --------------------------

paren_expr: "(" value+ ")"
tilde_block: TILDE_START tilde_content TILDE_END
tilde_content: value*

// ----------
// Terminal Definitions
// ----------

TILDE_START: "<{"
TILDE_END: "}>"

// 3) STRING
STRING: /(f)?('''.*?'''|\"\"\".*?\"\"\"|```.*?```|'(?:\\.|[^'\\])*'|\"(?:\\.|[^\"\\])*\"|`(?:\\.|[^`\\])*`)/s

// 4) SCOPED_VAR
SCOPED_VAR: /[@%$]\{[^}]+\}/

// 5) COMMENT
COMMENT.1: /\#[^\n]*/

INLINE_COMMENT: /[ \t]+#[^\n]*/

// 6) FLOAT
FLOAT: /[+-]?(?:\d+\.\d*|\.\d+)(?:[eE][+-]?\d+)?|[+-]?(?:inf|nan)/

// 7) INTEGER
INTEGER: /0[oO][0-7]+|0[xX][0-9a-fA-F]+|0[bB][01]+|[+-]?(?:0|[1-9]\d*)/

// 8) BOOLEAN
BOOLEAN: /(true|false)\b/

// 9) NULL
NULL: /null\b/

// 10) RESERVED_FUNC
RESERVED_FUNC: /(File\(\)|Git\(\))\b/

// 11) KEYWORD
KEYWORD.2: /\b(?:is|not|and|or|if|elif|else|for|in|enumerate|include)\b/

// 12) TABLE_ARRAY
TABLE_ARRAY: /\[\[[^\]\n]+\]\]/

// 13) TABLE_SECTION
TABLE_SECTION: /\[[A-Za-z0-9_.\-]+\]/

// 15) FOLDER_BLOCK
FOLDER_BLOCK: /\{\^.*?\^\}/s

// 18) IDENTIFIER
IDENTIFIER: /(?!\b(?:is|not|and|or|if|elif|else|for|in|enumerate|include|File|Git)\b)\b[a-zA-Z_][a-zA-Z0-9_-]*\b/

// 19) OPERATOR
OPERATOR: /\*\*|==|!=|>=|<=|->|<<|\+|-|\*|\/|%|>|<(?!{)/

// 21) WHITESPACE
WHITESPACE: /\s+/

// If you want to allow inline whitespace for inline_comment:
INLINE_WS: /[ \t]+/